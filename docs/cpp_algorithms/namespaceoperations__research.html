<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>OR-Tools</title>
        <meta http-equiv="Content-Type" content="text/html;"/>
        <meta charset="utf-8"/>
        <!--<link rel='stylesheet' type='text/css' href="https://fonts.googleapis.com/css?family=Ubuntu:400,700,400italic"/>-->
        <link rel="stylesheet" type="text/css" href="ortools.css" title="default" media="screen,print" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
    </head>
    <body>
        <div id="banner-container">
            <div id="banner">
                <span id="sfml">OR-Tools 7.2</span>
            </div>
        </div>
        <link rel="icon" href="https://developers.google.com/optimization/images/orLogo.png">
        <div id="content">
<!-- Generated by Doxygen 1.8.15 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">operations_research Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1BaseKnapsackSolver.html">BaseKnapsackSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; <a class="el" href="classoperations__research_1_1BaseKnapsackSolver.html" title="--— BaseKnapsackSolver --— This is the base class for knapsack solvers.">BaseKnapsackSolver</a> --&mdash; This is the base class for knapsack solvers.  <a href="classoperations__research_1_1BaseKnapsackSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1DenseDoublyLinkedList.html">DenseDoublyLinkedList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized doubly-linked list that initially holds [0..n-1] in an arbitrary (user-specified) and fixed order.  <a href="classoperations__research_1_1DenseDoublyLinkedList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1DynamicPartition.html">DynamicPartition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition class that supports incremental splitting, with backtracking.  <a href="classoperations__research_1_1DynamicPartition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1DynamicPermutation.html">DynamicPermutation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintains a 'partial' permutation of [0..n-1] onto itself, with a dynamic API allowing it to be built incrementally, and allowing some backtracking.  <a href="classoperations__research_1_1DynamicPermutation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1GraphSymmetryFinder.html">GraphSymmetryFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1KnapsackAssignment.html">KnapsackAssignment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; KnapsackAssignement --&mdash; KnapsackAssignement is a small struct used to pair an item with its assignment.  <a href="structoperations__research_1_1KnapsackAssignment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1KnapsackCapacityPropagator.html">KnapsackCapacityPropagator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; <a class="el" href="classoperations__research_1_1KnapsackCapacityPropagator.html" title="--— KnapsackCapacityPropagator --— KnapsackCapacityPropagator is a KnapsackPropagator used to enforce...">KnapsackCapacityPropagator</a> --&mdash; <a class="el" href="classoperations__research_1_1KnapsackCapacityPropagator.html" title="--— KnapsackCapacityPropagator --— KnapsackCapacityPropagator is a KnapsackPropagator used to enforce...">KnapsackCapacityPropagator</a> is a <a class="el" href="classoperations__research_1_1KnapsackPropagator.html" title="--— KnapsackPropagator --— KnapsackPropagator is the base class for modeling and propagating a constr...">KnapsackPropagator</a> used to enforce a capacity constraint.  <a href="classoperations__research_1_1KnapsackCapacityPropagator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1KnapsackGenericSolver.html">KnapsackGenericSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; <a class="el" href="classoperations__research_1_1KnapsackGenericSolver.html" title="--— KnapsackGenericSolver --— KnapsackGenericSolver is the multi-dimensional knapsack solver class.">KnapsackGenericSolver</a> --&mdash; <a class="el" href="classoperations__research_1_1KnapsackGenericSolver.html" title="--— KnapsackGenericSolver --— KnapsackGenericSolver is the multi-dimensional knapsack solver class.">KnapsackGenericSolver</a> is the multi-dimensional knapsack solver class.  <a href="classoperations__research_1_1KnapsackGenericSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1KnapsackItem.html">KnapsackItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; <a class="el" href="structoperations__research_1_1KnapsackItem.html" title="--— KnapsackItem --— KnapsackItem is a small struct to pair an item weight with its corresponding pro...">KnapsackItem</a> --&mdash; <a class="el" href="structoperations__research_1_1KnapsackItem.html" title="--— KnapsackItem --— KnapsackItem is a small struct to pair an item weight with its corresponding pro...">KnapsackItem</a> is a small struct to pair an item weight with its corresponding profit.  <a href="structoperations__research_1_1KnapsackItem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1KnapsackPropagator.html">KnapsackPropagator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; <a class="el" href="classoperations__research_1_1KnapsackPropagator.html" title="--— KnapsackPropagator --— KnapsackPropagator is the base class for modeling and propagating a constr...">KnapsackPropagator</a> --&mdash; <a class="el" href="classoperations__research_1_1KnapsackPropagator.html" title="--— KnapsackPropagator --— KnapsackPropagator is the base class for modeling and propagating a constr...">KnapsackPropagator</a> is the base class for modeling and propagating a constraint given an assignment.  <a href="classoperations__research_1_1KnapsackPropagator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1KnapsackSearchNode.html">KnapsackSearchNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; <a class="el" href="classoperations__research_1_1KnapsackSearchNode.html" title="--— KnapsackSearchNode --— KnapsackSearchNode is a class used to describe a decision in the decision ...">KnapsackSearchNode</a> --&mdash; <a class="el" href="classoperations__research_1_1KnapsackSearchNode.html" title="--— KnapsackSearchNode --— KnapsackSearchNode is a class used to describe a decision in the decision ...">KnapsackSearchNode</a> is a class used to describe a decision in the decision search tree.  <a href="classoperations__research_1_1KnapsackSearchNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1KnapsackSearchPath.html">KnapsackSearchPath</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; <a class="el" href="classoperations__research_1_1KnapsackSearchPath.html" title="--— KnapsackSearchPath --— KnapsackSearchPath is a small class used to represent the path between a n...">KnapsackSearchPath</a> --&mdash; <a class="el" href="classoperations__research_1_1KnapsackSearchPath.html" title="--— KnapsackSearchPath --— KnapsackSearchPath is a small class used to represent the path between a n...">KnapsackSearchPath</a> is a small class used to represent the path between a node to another node in the search tree.  <a href="classoperations__research_1_1KnapsackSearchPath.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1KnapsackSolver.html">KnapsackSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1KnapsackState.html">KnapsackState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; <a class="el" href="classoperations__research_1_1KnapsackState.html" title="--— KnapsackState --— KnapsackState represents a partial solution to the knapsack problem.">KnapsackState</a> --&mdash; <a class="el" href="classoperations__research_1_1KnapsackState.html" title="--— KnapsackState --— KnapsackState represents a partial solution to the knapsack problem.">KnapsackState</a> represents a partial solution to the knapsack problem.  <a href="classoperations__research_1_1KnapsackState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MergingPartition.html">MergingPartition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition class that supports incremental merging, using the union-find algorithm (see <a href="http://en.wikipedia.org/wiki/Disjoint-set_data_structure">http://en.wikipedia.org/wiki/Disjoint-set_data_structure</a>).  <a href="classoperations__research_1_1MergingPartition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1SparsePermutation.html">SparsePermutation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compact representation for permutations of {0..N-1} that displaces few elements: it needs only O(K) memory for a permutation that displaces K elements.  <a href="classoperations__research_1_1SparsePermutation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab6f3adbb119982fdfb9a85d87310f255"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structoperations__research_1_1KnapsackItem.html">KnapsackItem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ab6f3adbb119982fdfb9a85d87310f255">KnapsackItemPtr</a></td></tr>
<tr class="separator:ab6f3adbb119982fdfb9a85d87310f255"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9c61bb2d6de0894f19675e2110458877"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a9c61bb2d6de0894f19675e2110458877">MinimizeLinearAssignment</a> (const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;cost, absl::flat_hash_map&lt; int, int &gt; *direct_assignment, absl::flat_hash_map&lt; int, int &gt; *reverse_assignment)</td></tr>
<tr class="memdesc:a9c61bb2d6de0894f19675e2110458877"><td class="mdescLeft">&#160;</td><td class="mdescRight">See IMPORTANT NOTE at the top of the file.  <a href="#a9c61bb2d6de0894f19675e2110458877">More...</a><br /></td></tr>
<tr class="separator:a9c61bb2d6de0894f19675e2110458877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8ccc36ef736b10ce389fbd347c4282"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ada8ccc36ef736b10ce389fbd347c4282">MaximizeLinearAssignment</a> (const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;cost, absl::flat_hash_map&lt; int, int &gt; *direct_assignment, absl::flat_hash_map&lt; int, int &gt; *reverse_assignment)</td></tr>
<tr class="memdesc:ada8ccc36ef736b10ce389fbd347c4282"><td class="mdescLeft">&#160;</td><td class="mdescRight">See IMPORTANT NOTE at the top of the file.  <a href="#ada8ccc36ef736b10ce389fbd347c4282">More...</a><br /></td></tr>
<tr class="separator:ada8ccc36ef736b10ce389fbd347c4282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0de44378545d5727eb4400210e568f8"><td class="memItemLeft" align="right" valign="top">Select next search node to expand Select next item_i to&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ab0de44378545d5727eb4400210e568f8">assign</a> (using master propagator) - Generate a new search node where item_i is in the knapsack - Check validity of this new partial <a class="el" href="namespaceoperations__research.html#a35a30dc825cd0afa0e095f47118cd3cd">solution</a>(using propagators) - If valid</td></tr>
<tr class="memdesc:ab0de44378545d5727eb4400210e568f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following code defines needed classes for the <a class="el" href="classoperations__research_1_1KnapsackGenericSolver.html" title="--— KnapsackGenericSolver --— KnapsackGenericSolver is the multi-dimensional knapsack solver class.">KnapsackGenericSolver</a> class which is the entry point to extend knapsack with new constraints such as conflicts between items.  <a href="#ab0de44378545d5727eb4400210e568f8">More...</a><br /></td></tr>
<tr class="separator:ab0de44378545d5727eb4400210e568f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a30dc825cd0afa0e095f47118cd3cd"><td class="memItemLeft" align="right" valign="top">Select next search node to expand Select next item_i to add this new search node to the search Generate a new search node where item_i is not in the knapsack Check validity of this new partial&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a35a30dc825cd0afa0e095f47118cd3cd">solution</a> (using propagators) - If valid</td></tr>
<tr class="separator:a35a30dc825cd0afa0e095f47118cd3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. </p>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>(user,user): refine this toplevel comment when this file settles.</dd></dl>
<p>Two dynamic partition classes: one that incrementally splits a partition into more and more parts; one that incrementally merges a partition into less and less parts.</p>
<p>GLOSSARY: The partition classes maintain a partition of N integers 0..N-1 (aka "elements") into disjoint equivalence classes (aka "parts").</p>
<p>SAFETY: Like std::vector&lt;int&gt; crashes when used improperly, these classes are not "safe": most of their methods may crash if called with invalid arguments. The client code is responsible for using this class properly. A few DCHECKs() will help catch bugs, though.</p>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. This class solves the graph automorphism problem (<a href="https://en.wikipedia.org/wiki/Graph_automorphism">https://en.wikipedia.org/wiki/Graph_automorphism</a>), a variant of the famous graph isomorphism problem (<a href="https://en.wikipedia.org/wiki/Graph_isomorphism">https://en.wikipedia.org/wiki/Graph_isomorphism</a>).</p>
<p>The algorithm is largely based on the following article, published in 2008: "Faster Symmetry Discovery using Sparsity of Symmetries" by Darga, Sakallah and Markov. <a href="http://web.eecs.umich.edu/~imarkov/pubs/conf/dac08-sym.pdf">http://web.eecs.umich.edu/~imarkov/pubs/conf/dac08-sym.pdf</a>.</p>
<p>See the comments on the class below for more details.</p>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. IMPORTANT NOTE: we advise using the code in graph/linear_assignment.h whose complexity is usually much smaller. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>(user): base this code on LinearSumAssignment. </dd></dl>
<p>An O(n^4) implementation of the Kuhn-Munkres algorithm (a.k.a. the Hungarian algorithm) for solving the assignment problem. The assignment problem takes a set of agents, a set of tasks and a cost associated with assigning each agent to each task and produces an optimal (i.e., least cost) assignment of agents to tasks. The code also enables computing a maximum assignment by changing the input matrix.</p>
<p>This code is based on (read: translated from) the Java version (read: translated from) the Python version at <a href="http://www.clapper.org/software/python/munkres/">http://www.clapper.org/software/python/munkres/</a>.</p>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. This library solves knapsacks:</p><ul>
<li>0-1 knapsack problems,</li>
<li>Multi-dimensional knapsack problems,</li>
<li><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>(user) Multi-dimensional knapsack problem with n-ary conflicts between items.</dd></dl>
</li>
</ul>
<p>Given n items, each with a profit and a weight, given a knapsack of capacity c, the goal is to find a subset of items which fits inside c and maximizes the total profit. The knapsack problem can easily be extended from 1 to d dimensions. As an example, this can be useful to constrain the maximum number of items inside the knapsack. Without loss of generality, profits and weights are assumed to be positive.</p>
<p>From a mathematical point of view, the multi-dimensional knapsack problem can be modeled by d linear constraints: ForEach(j:1..d)(Sum(i:1..n)(weight_ij * item_i) &lt;= c_j where item_i is a 0-1 integer variable. Then the goal is to maximize: Sum(i:1..n)(profit_i * item_i).</p>
<p>There are several ways to solve knapsack problems. One of the most efficient ways is based on dynamic programming (mainly when weights, profits and dimensions are small, the algorithm runs in pseudo polynomial time). Unfortunately when adding conflict constraints the problem becomes strongly NP-hard, i.e. there is no pseudo-polynomial algorithm to solve it. That's the reason why the most of the following code is based on branch and bound search.</p>
<p>For instance to solve a 2-dimensional knapsack problem with 9 items, one just has to feed a profit vector with the 9 profits, a vector of 2 vectors for weights, and a vector of capacities. E.g.: vector: profits = [1, 2, 3, 4, 5, 6, 7, 8, 9] vector of vector: weights = [ [1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 1, 1, 1, 1, 1, 1, 1, 1]] vector: capacities = [34, 4] And then: <a class="el" href="classoperations__research_1_1KnapsackSolver.html">KnapsackSolver</a> solver( <a class="el" href="classoperations__research_1_1KnapsackSolver.html#a81ce17438663c39f7793e8db92ff1893ae8c15c25eaf606f5f853821aaabba164">KnapsackSolver::KNAPSACK_MULTIDIMENSION_BRANCH_AND_BOUND_SOLVER</a>, "Multi-dimensional solver"); solver.Init(profits, weights, capacities); int64 profit = solver.Solve();</p>
<p>Currently four algorithms are implemented:</p><ul>
<li>KNAPSACK_BRUTE_FORCE_SOLVER: Limited to 30 items and one dimension, this solver uses a brute force algorithm, ie. explores all possible states. Experiments show competitive performance for instances with less than - KNAPSACK_64ITEMS_SOLVER: Limited to 64 items and one dimension, this solver uses a branch &amp; bound algorithm. This solver is about 4 times faster than KNAPSACK_MULTIDIMENSION_BRANCH_AND_BOUND_SOLVER.</li>
</ul>
<p>KNAPSACK_DYNAMIC_PROGRAMMING_SOLVER: Limited to one dimension, this solver is based on a dynamic programming algorithm. The time and space complexity is O(capacity * number_of_items).</p><ul>
<li>KNAPSACK_MULTIDIMENSION_BRANCH_AND_BOUND_SOLVER: This solver can deal with both large number of items and several dimensions. This solver is based on branch and bound.</li>
<li>KNAPSACK_MULTIDIMENSION_CBC_MIP_SOLVER: This solver can deal with both large number of items and several dimensions. This solver is based on Integer Programming solver CBC.</li>
<li>KNAPSACK_MULTIDIMENSION_SCIP_MIP_SOLVER: This solver can deal with both large number of items and several dimensions. This solver is based on Integer Programming solver SCIP. </li>
</ul>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ab6f3adbb119982fdfb9a85d87310f255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f3adbb119982fdfb9a85d87310f255">&#9670;&nbsp;</a></span>KnapsackItemPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structoperations__research_1_1KnapsackItem.html">KnapsackItem</a>* <a class="el" href="namespaceoperations__research.html#ab6f3adbb119982fdfb9a85d87310f255">operations_research::KnapsackItemPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="knapsack__solver_8h_source.html#l00249">249</a> of file <a class="el" href="knapsack__solver_8h_source.html">knapsack_solver.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab0de44378545d5727eb4400210e568f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0de44378545d5727eb4400210e568f8">&#9670;&nbsp;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Select next search node to expand Select next item_i to operations_research::assign </td>
          <td>(</td>
          <td class="paramtype">using master&#160;</td>
          <td class="paramname"><em>propagator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">new</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The following code defines needed classes for the <a class="el" href="classoperations__research_1_1KnapsackGenericSolver.html" title="--— KnapsackGenericSolver --— KnapsackGenericSolver is the multi-dimensional knapsack solver class.">KnapsackGenericSolver</a> class which is the entry point to extend knapsack with new constraints such as conflicts between items. </p>
<p>Constraints are enforced using <a class="el" href="classoperations__research_1_1KnapsackPropagator.html" title="--— KnapsackPropagator --— KnapsackPropagator is the base class for modeling and propagating a constr...">KnapsackPropagator</a> objects, in the current code there is one propagator per dimension (<a class="el" href="classoperations__research_1_1KnapsackCapacityPropagator.html" title="--— KnapsackCapacityPropagator --— KnapsackCapacityPropagator is a KnapsackPropagator used to enforce...">KnapsackCapacityPropagator</a>). One of those propagators, named master propagator, is used to guide the search, i.e. decides which item should be assigned next. Roughly speaking the search algorithm is:</p><ul>
<li>While not optimal </li>
</ul>

</div>
</div>
<a id="ada8ccc36ef736b10ce389fbd347c4282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8ccc36ef736b10ce389fbd347c4282">&#9670;&nbsp;</a></span>MaximizeLinearAssignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::MaximizeLinearAssignment </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::flat_hash_map&lt; int, int &gt; *&#160;</td>
          <td class="paramname"><em>direct_assignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::flat_hash_map&lt; int, int &gt; *&#160;</td>
          <td class="paramname"><em>reverse_assignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See IMPORTANT NOTE at the top of the file. </p>

</div>
</div>
<a id="a9c61bb2d6de0894f19675e2110458877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c61bb2d6de0894f19675e2110458877">&#9670;&nbsp;</a></span>MinimizeLinearAssignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::MinimizeLinearAssignment </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::flat_hash_map&lt; int, int &gt; *&#160;</td>
          <td class="paramname"><em>direct_assignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::flat_hash_map&lt; int, int &gt; *&#160;</td>
          <td class="paramname"><em>reverse_assignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See IMPORTANT NOTE at the top of the file. </p>

</div>
</div>
<a id="a35a30dc825cd0afa0e095f47118cd3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35a30dc825cd0afa0e095f47118cd3cd">&#9670;&nbsp;</a></span>solution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Select next search node to expand Select next item_i to add this new search node to the search Generate a new search node where item_i is not in the knapsack Check validity of this new partial operations_research::solution </td>
          <td>(</td>
          <td class="paramtype">using&#160;</td>
          <td class="paramname"><em>propagators</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
        </div>
        <div id="footer-container">
            <div id="footer">
            </div>
        </div>
    </body>
</html>
