<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>OR-Tools</title>
        <meta http-equiv="Content-Type" content="text/html;"/>
        <meta charset="utf-8"/>
        <!--<link rel='stylesheet' type='text/css' href="https://fonts.googleapis.com/css?family=Ubuntu:400,700,400italic"/>-->
        <link rel="stylesheet" type="text/css" href="ortools.css" title="default" media="screen,print" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
    </head>
    <body>
        <div id="banner-container">
            <div id="banner">
                <span id="sfml">OR-Tools 7.2</span>
            </div>
        </div>
        <link rel="icon" href="https://developers.google.com/optimization/images/orLogo.png">
        <div id="content">
<!-- Generated by Doxygen 1.8.15 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceoperations__research.html">operations_research</a></li><li class="navelem"><a class="el" href="classoperations__research_1_1DynamicPermutation.html">DynamicPermutation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classoperations__research_1_1DynamicPermutation-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">operations_research::DynamicPermutation Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Maintains a 'partial' permutation of [0..n-1] onto itself, with a dynamic API allowing it to be built incrementally, and allowing some backtracking.  
 <a href="classoperations__research_1_1DynamicPermutation.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="dynamic__permutation_8h_source.html">dynamic_permutation.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5743ffc1c6fb22b0c4d63ce242135cbe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1DynamicPermutation.html#a5743ffc1c6fb22b0c4d63ce242135cbe">DynamicPermutation</a> (int n)</td></tr>
<tr class="memdesc:a5743ffc1c6fb22b0c4d63ce242135cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upon construction, every element i in [0..n-1] maps to itself.  <a href="#a5743ffc1c6fb22b0c4d63ce242135cbe">More...</a><br /></td></tr>
<tr class="separator:a5743ffc1c6fb22b0c4d63ce242135cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e31debbde606afd35a1a8e4a366a5da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1DynamicPermutation.html#a3e31debbde606afd35a1a8e4a366a5da">Size</a> () const</td></tr>
<tr class="separator:a3e31debbde606afd35a1a8e4a366a5da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1058ff0d3ae20f6f313a82e12febbbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1DynamicPermutation.html#af1058ff0d3ae20f6f313a82e12febbbf">AddMappings</a> (const std::vector&lt; int &gt; &amp;src, const std::vector&lt; int &gt; &amp;dst)</td></tr>
<tr class="memdesc:af1058ff0d3ae20f6f313a82e12febbbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a set of mappings for this permutation: src[i] will map to dst[i].  <a href="#af1058ff0d3ae20f6f313a82e12febbbf">More...</a><br /></td></tr>
<tr class="separator:af1058ff0d3ae20f6f313a82e12febbbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5493ce64ddd5b10144e57a0e630c1657"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1DynamicPermutation.html#a5493ce64ddd5b10144e57a0e630c1657">UndoLastMappings</a> (std::vector&lt; int &gt; *undone_mapping_src)</td></tr>
<tr class="memdesc:a5493ce64ddd5b10144e57a0e630c1657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undoes the last <a class="el" href="classoperations__research_1_1DynamicPermutation.html#af1058ff0d3ae20f6f313a82e12febbbf" title="Declares a set of mappings for this permutation: src[i] will map to dst[i].">AddMappings()</a> operation, and fills the "undone_mapping_src" vector with the src of that last operation.  <a href="#a5493ce64ddd5b10144e57a0e630c1657">More...</a><br /></td></tr>
<tr class="separator:a5493ce64ddd5b10144e57a0e630c1657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439e971c48da03d73621df8149c27167"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1DynamicPermutation.html#a439e971c48da03d73621df8149c27167">Reset</a> ()</td></tr>
<tr class="memdesc:a439e971c48da03d73621df8149c27167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the permutation back to the identity (i.e.  <a href="#a439e971c48da03d73621df8149c27167">More...</a><br /></td></tr>
<tr class="separator:a439e971c48da03d73621df8149c27167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455f2fd63b17930ebb1d9a72f642ebd9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1DynamicPermutation.html#a455f2fd63b17930ebb1d9a72f642ebd9">ImageOf</a> (int i) const</td></tr>
<tr class="memdesc:a455f2fd63b17930ebb1d9a72f642ebd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forced-inline for the speed.  <a href="#a455f2fd63b17930ebb1d9a72f642ebd9">More...</a><br /></td></tr>
<tr class="separator:a455f2fd63b17930ebb1d9a72f642ebd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2bde228e58a2d71d457b0329f6ab2a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1DynamicPermutation.html#a5f2bde228e58a2d71d457b0329f6ab2a">AllMappingsSrc</a> () const</td></tr>
<tr class="memdesc:a5f2bde228e58a2d71d457b0329f6ab2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the union of all "src" ever given to <a class="el" href="classoperations__research_1_1DynamicPermutation.html#af1058ff0d3ae20f6f313a82e12febbbf" title="Declares a set of mappings for this permutation: src[i] will map to dst[i].">AddMappings()</a>.  <a href="#a5f2bde228e58a2d71d457b0329f6ab2a">More...</a><br /></td></tr>
<tr class="separator:a5f2bde228e58a2d71d457b0329f6ab2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a6e9c551114feee802a46a49cf2b4a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1DynamicPermutation.html#a26a6e9c551114feee802a46a49cf2b4a">RootOf</a> (int i) const</td></tr>
<tr class="memdesc:a26a6e9c551114feee802a46a49cf2b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">While the permutation is partially being built, the orbit of elements will either form unclosed paths, or closed cycles.  <a href="#a26a6e9c551114feee802a46a49cf2b4a">More...</a><br /></td></tr>
<tr class="separator:a26a6e9c551114feee802a46a49cf2b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9308c2eb8d7c1d5b5e3193c672f36d"><td class="memItemLeft" align="right" valign="top">const std::set&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1DynamicPermutation.html#acf9308c2eb8d7c1d5b5e3193c672f36d">LooseEnds</a> () const</td></tr>
<tr class="memdesc:acf9308c2eb8d7c1d5b5e3193c672f36d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exhaustive set of the 'loose end' of the incomplete cycles (e.g., paths) built so far.  <a href="#acf9308c2eb8d7c1d5b5e3193c672f36d">More...</a><br /></td></tr>
<tr class="separator:acf9308c2eb8d7c1d5b5e3193c672f36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0264e56e82c46a27db9b57ed58cd45"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classoperations__research_1_1SparsePermutation.html">SparsePermutation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1DynamicPermutation.html#afc0264e56e82c46a27db9b57ed58cd45">CreateSparsePermutation</a> () const</td></tr>
<tr class="memdesc:afc0264e56e82c46a27db9b57ed58cd45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classoperations__research_1_1SparsePermutation.html" title="A compact representation for permutations of {0..N-1} that displaces few elements: it needs only O(K)...">SparsePermutation</a> representing the current permutation.  <a href="#afc0264e56e82c46a27db9b57ed58cd45">More...</a><br /></td></tr>
<tr class="separator:afc0264e56e82c46a27db9b57ed58cd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae095cf4e546b2a3048a4f424fcd1e770"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1DynamicPermutation.html#ae095cf4e546b2a3048a4f424fcd1e770">DebugString</a> () const</td></tr>
<tr class="separator:ae095cf4e546b2a3048a4f424fcd1e770"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Maintains a 'partial' permutation of [0..n-1] onto itself, with a dynamic API allowing it to be built incrementally, and allowing some backtracking. </p>
<p>This is tuned for a specific usage by ./find_graph_symmetries.cc.</p>
<p>RAM usage: as of 2014-04, this class needs less than: 32.125 * (n + 2 * support_size) bytes. </p>

<p class="definition">Definition at line <a class="el" href="dynamic__permutation_8h_source.html#l00033">33</a> of file <a class="el" href="dynamic__permutation_8h_source.html">dynamic_permutation.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5743ffc1c6fb22b0c4d63ce242135cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5743ffc1c6fb22b0c4d63ce242135cbe">&#9670;&nbsp;</a></span>DynamicPermutation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::DynamicPermutation::DynamicPermutation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Upon construction, every element i in [0..n-1] maps to itself. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af1058ff0d3ae20f6f313a82e12febbbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1058ff0d3ae20f6f313a82e12febbbf">&#9670;&nbsp;</a></span>AddMappings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::DynamicPermutation::AddMappings </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares a set of mappings for this permutation: src[i] will map to dst[i]. </p>
<p>Requirements that are DCHECKed:</p><ul>
<li>"src" and "dst" must have the same size.</li>
<li>For all i, src[i] must not already be mapped to something.</li>
<li>For all i, dst[i] must not already be the image of something.</li>
</ul>
<p>Complexity: amortized O(src.size()). </p>

</div>
</div>
<a id="a5f2bde228e58a2d71d457b0329f6ab2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f2bde228e58a2d71d457b0329f6ab2a">&#9670;&nbsp;</a></span>AllMappingsSrc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;int&gt;&amp; operations_research::DynamicPermutation::AllMappingsSrc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the union of all "src" ever given to <a class="el" href="classoperations__research_1_1DynamicPermutation.html#af1058ff0d3ae20f6f313a82e12febbbf" title="Declares a set of mappings for this permutation: src[i] will map to dst[i].">AddMappings()</a>. </p>

<p class="definition">Definition at line <a class="el" href="dynamic__permutation_8h_source.html#l00067">67</a> of file <a class="el" href="dynamic__permutation_8h_source.html">dynamic_permutation.h</a>.</p>

</div>
</div>
<a id="afc0264e56e82c46a27db9b57ed58cd45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc0264e56e82c46a27db9b57ed58cd45">&#9670;&nbsp;</a></span>CreateSparsePermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classoperations__research_1_1SparsePermutation.html">SparsePermutation</a>&gt; operations_research::DynamicPermutation::CreateSparsePermutation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classoperations__research_1_1SparsePermutation.html" title="A compact representation for permutations of {0..N-1} that displaces few elements: it needs only O(K)...">SparsePermutation</a> representing the current permutation. </p>
<p>Requirements: the permutation must only have cycles.</p>
<p>Complexity: O(support size). </p>

</div>
</div>
<a id="ae095cf4e546b2a3048a4f424fcd1e770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae095cf4e546b2a3048a4f424fcd1e770">&#9670;&nbsp;</a></span>DebugString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string operations_research::DynamicPermutation::DebugString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a455f2fd63b17930ebb1d9a72f642ebd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455f2fd63b17930ebb1d9a72f642ebd9">&#9670;&nbsp;</a></span>ImageOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::DynamicPermutation::ImageOf </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forced-inline for the speed. </p>

<p class="definition">Definition at line <a class="el" href="dynamic__permutation_8h_source.html#l00114">114</a> of file <a class="el" href="dynamic__permutation_8h_source.html">dynamic_permutation.h</a>.</p>

</div>
</div>
<a id="acf9308c2eb8d7c1d5b5e3193c672f36d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9308c2eb8d7c1d5b5e3193c672f36d">&#9670;&nbsp;</a></span>LooseEnds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt;int&gt;&amp; operations_research::DynamicPermutation::LooseEnds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The exhaustive set of the 'loose end' of the incomplete cycles (e.g., paths) built so far. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>(user): use a faster underlying container like SparseBitSet, and tweak this API accordingly. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dynamic__permutation_8h_source.html#l00083">83</a> of file <a class="el" href="dynamic__permutation_8h_source.html">dynamic_permutation.h</a>.</p>

</div>
</div>
<a id="a439e971c48da03d73621df8149c27167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439e971c48da03d73621df8149c27167">&#9670;&nbsp;</a></span>Reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::DynamicPermutation::Reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes the permutation back to the identity (i.e. </p>
<p>like right after construction). Complexity: O(support size). </p>

</div>
</div>
<a id="a26a6e9c551114feee802a46a49cf2b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26a6e9c551114feee802a46a49cf2b4a">&#9670;&nbsp;</a></span>RootOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::DynamicPermutation::RootOf </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>While the permutation is partially being built, the orbit of elements will either form unclosed paths, or closed cycles. </p>
<p>Forced-inline for the speed.</p>
<p>In the former case, RootOf(i) returns the start of the path where i lies. If i is on a cycle, RootOf(i) will return some element of its cycle (meaning that if i maps to itself, RootOf(i) = i).</p>
<p>Complexity: O(log(orbit size)) in average, assuming that the mappings are added in a random order. O(orbit size) in the worst case. </p>

<p class="definition">Definition at line <a class="el" href="dynamic__permutation_8h_source.html#l00121">121</a> of file <a class="el" href="dynamic__permutation_8h_source.html">dynamic_permutation.h</a>.</p>

</div>
</div>
<a id="a3e31debbde606afd35a1a8e4a366a5da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e31debbde606afd35a1a8e4a366a5da">&#9670;&nbsp;</a></span>Size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::DynamicPermutation::Size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dynamic__permutation_8h_source.html#l00038">38</a> of file <a class="el" href="dynamic__permutation_8h_source.html">dynamic_permutation.h</a>.</p>

</div>
</div>
<a id="a5493ce64ddd5b10144e57a0e630c1657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5493ce64ddd5b10144e57a0e630c1657">&#9670;&nbsp;</a></span>UndoLastMappings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::DynamicPermutation::UndoLastMappings </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>undone_mapping_src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undoes the last <a class="el" href="classoperations__research_1_1DynamicPermutation.html#af1058ff0d3ae20f6f313a82e12febbbf" title="Declares a set of mappings for this permutation: src[i] will map to dst[i].">AddMappings()</a> operation, and fills the "undone_mapping_src" vector with the src of that last operation. </p>
<p>This works like an undo stack. For example, applying the sequence (Add, Add, Add, Undo, Add, Undo, Undo) has exactly the same effect as applying the first Add() alone. If you call this too may times (i.e. there is nothing left to undo), it is simply a no-op.</p>
<p>Complexity: same as the <a class="el" href="classoperations__research_1_1DynamicPermutation.html#af1058ff0d3ae20f6f313a82e12febbbf" title="Declares a set of mappings for this permutation: src[i] will map to dst[i].">AddMappings()</a> operation being undone. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="dynamic__permutation_8h_source.html">dynamic_permutation.h</a></li>
</ul>
</div><!-- contents -->
        </div>
        <div id="footer-container">
            <div id="footer">
            </div>
        </div>
    </body>
</html>
